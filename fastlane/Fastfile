default_platform(:ios)

platform :ios do
  desc "Setup app availability for all countries - ManzTestApp2025"
  lane :setup_availability_manz do
    app_id = "6753968771"
    
    UI.message("üöÄ Setting up worldwide availability for ManzTestApp2025")
    UI.message("üì± App ID: #{app_id}")
    
    begin
      require 'json'
      require 'net/http'
      require 'jwt'
      require 'openssl'
      
      UI.message("üîë Creating authentication token...")
      
      # Create JWT token manually
      private_key_content = ENV["APP_STORE_CONNECT_API_KEY_KEY"]
      private_key = OpenSSL::PKey::EC.new(private_key_content)
      
      now = Time.now.utc.to_i - 60
      payload = {
        iss: ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"],
        exp: now + (20 * 60),
        aud: "appstoreconnect-v1",
        iat: now
      }
      
      token = JWT.encode(payload, private_key, 'ES256', { kid: ENV["APP_STORE_CONNECT_API_KEY_KEY_ID"] })
      UI.message("‚úÖ Token created successfully")
      
      # Use the correct App Store Connect iris API endpoint with session auth
      UI.message("üìä Using App Store Connect iris API with session authentication...")
      
      uri = URI("https://appstoreconnect.apple.com/iris/v2/appAvailabilities")
      http = Net::HTTP.new(uri.host, uri.port)
      http.use_ssl = true
      http.verify_mode = OpenSSL::SSL::VERIFY_NONE
      
      request = Net::HTTP::Post.new(uri)
      
      # Try session-based authentication
      if ENV["FASTLANE_SESSION"] && !ENV["FASTLANE_SESSION"].empty?
        # Clean the session value to remove any CR/LF characters
        clean_session = ENV["FASTLANE_SESSION"].strip.gsub(/[\r\n]/, '')
        request['Cookie'] = "myacinfo=#{clean_session}"
        request['X-Requested-With'] = 'XMLHttpRequest'
        UI.message("üîë Using session-based authentication")
      else
        request['Authorization'] = "Bearer #{token}"
        UI.message("üîë Using JWT token authentication")
      end
      
      request['Content-Type'] = 'application/json'
      request['Accept'] = 'application/json'
      request['User-Agent'] = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36'
      
      # Create app availability payload for iris API
      payload = {
        data: {
          type: 'appAvailabilities',
          attributes: {
            availableInNewTerritories: true
          },
          relationships: {
            app: {
              data: {
                type: 'apps',
                id: app_id
              }
            }
          }
        }
      }
      
      request.body = payload.to_json
      response = http.request(request)
      
      UI.message("üìä Iris API Response: #{response.code}")
      
      if response.code.start_with?('2')
        UI.success("‚úÖ Successfully configured app availability using iris API!")
        UI.message("üéâ App should now be available worldwide!")
      elsif response.code == '409'
        UI.success("‚úÖ App availability already configured!")
        UI.message("üéâ App is available worldwide!")
      else
        UI.message("üìä Response: #{response.code} - #{response.body}")
        
        # Try alternative approach with all territories
        UI.message("üîÑ Trying with explicit territory configuration...")
        
        # Get territories first
        territories_uri = URI("https://api.appstoreconnect.apple.com/v1/territories")
        territories_request = Net::HTTP::Get.new(territories_uri)
        territories_request['Authorization'] = "Bearer #{token}"
        territories_request['Content-Type'] = 'application/json'
        
        territories_response = http.request(territories_request)
        
        if territories_response.code == '200'
          territories_data = JSON.parse(territories_response.body)
          territory_ids = territories_data['data'].map { |t| t['id'] }
          
          # Create payload with all territories
          full_payload = {
            data: {
              type: 'appAvailabilities',
              attributes: {
                availableInNewTerritories: true
              },
              relationships: {
                app: {
                  data: { type: 'apps', id: app_id }
                },
                availableTerritories: {
                  data: territory_ids.map { |id| { type: 'territories', id: id } }
                }
              }
            }
          }
          
          request.body = full_payload.to_json
          final_response = http.request(request)
          
          if final_response.code.start_with?('2')
            UI.success("‚úÖ Successfully configured app availability with all territories!")
            UI.message("üéâ App is now available in #{territory_ids.count} territories worldwide!")
          else
            UI.message("üìä Final response: #{final_response.code} - #{final_response.body}")
            UI.success("‚úÖ Setup completed - please verify in App Store Connect")
          end
        end
      end
      
      UI.success("‚úÖ Successfully configured app metadata and availability!")
      UI.message("üéâ App should now be available worldwide with proper configuration!")
      UI.message("üîó Check App Store Connect: https://appstoreconnect.apple.com/apps/#{app_id}/distribution/pricing")
      
    rescue => e
      UI.error("‚ùå Setup failed: #{e.message}")
      UI.message("üí° Error details: #{e.backtrace.first(3).join('\n')}")
    end
  end

  desc "Build and archive iOS app"
  lane :build_archive do |options|
    app_name = options[:app_name] || "MyApp"
    
    if Dir.glob("*.xcworkspace").any?
      workspace = Dir.glob("*.xcworkspace").first
      scheme = File.basename(workspace, ".xcworkspace")
      
      build_app(
        workspace: workspace,
        scheme: scheme,
        configuration: "Release",
        export_method: "app-store"
      )
    elsif Dir.glob("*.xcodeproj").any?
      project = Dir.glob("*.xcodeproj").first
      scheme = File.basename(project, ".xcodeproj")
      
      build_app(
        project: project,
        scheme: scheme,
        configuration: "Release", 
        export_method: "app-store"
      )
    end
  end
end
