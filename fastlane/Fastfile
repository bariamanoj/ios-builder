default_platform(:ios)

platform :ios do
  desc "Build and archive iOS app"
  lane :build_archive do |options|
    app_name = options[:app_name] || "MyApp"
    bundle_id = options[:bundle_id] || "com.example.app"
    
    # Find project/workspace
    if Dir.glob("*.xcworkspace").any?
      workspace = Dir.glob("*.xcworkspace").first
      scheme = File.basename(workspace, ".xcworkspace")
      
      build_app(
        workspace: workspace,
        scheme: scheme,
        configuration: "Release",
        export_method: "app-store",
        archive_path: "./build/#{scheme}.xcarchive",
        output_directory: "./build/ipa",
        output_name: "#{app_name}.ipa"
      )
    elsif Dir.glob("*.xcodeproj").any?
      project = Dir.glob("*.xcodeproj").first
      scheme = File.basename(project, ".xcodeproj")
      
      build_app(
        project: project,
        scheme: scheme,
        configuration: "Release",
        export_method: "app-store",
        archive_path: "./build/#{scheme}.xcarchive",
        output_directory: "./build/ipa",
        output_name: "#{app_name}.ipa"
      )
    end
  end

  desc "Create app on App Store Connect"
  lane :create_app do |options|
    app_name = options[:app_name] || "MyApp"
    bundle_id = options[:bundle_id] || "com.example.app"
    
    produce(
      username: "dohrasanket@gmail.com",
      app_name: app_name,
      app_identifier: bundle_id,
      language: "en-US",
      app_version: "1.0",
      sku: bundle_id == "com.san.mainAp" ? "ManzTestApp2025" : "#{bundle_id.gsub('.', '-')}-#{Time.now.to_i}",
      skip_itc: false,
      skip_devcenter: false
    )
  end 

  desc "Upload IPA to App Store Connect"
  lane :upload_ipa do |options|
    ipa_path = options[:ipa_path] || Dir.glob("./build/ipa/*.ipa").first
    
    if ipa_path && File.exist?(ipa_path)
      upload_to_testflight(
        username: "dohrasanket@gmail.com",
        ipa: ipa_path,
        skip_waiting_for_build_processing: true
      )
    else
      UI.error("No IPA file found at #{ipa_path}")
    end
  end

  desc "Upload metadata to App Store Connect"
  lane :upload_metadata do |options|
    deliver(
      username: "dohrasanket@gmail.com",
      app_identifier: options[:bundle_id] || "com.san.mainAp",
      metadata_path: "./metadata",
      screenshots_path: "./screenshots",
      skip_binary_upload: true,
      skip_screenshots: true,
      force: true,
      overwrite_screenshots: false,
      submit_for_review: false,
      automatic_release: false,
      skip_app_version_update: true,
      app_version: "1.0",
      copyright: "@ManzzPlusApp",
      primary_category: "UTILITIES",
      price_tier: 0,
      keywords: {
        "en-US" => "ManzzPlusApp"
      },
      description: {
        "en-US" => options[:description] || "ManzTestApp2025 - A utility application"
      },
      name: {
        "en-US" => options[:app_name] || "ManzTestApp2025"
      },
      support_url: {
        "en-US" => "https://manzz.app/support"
      },
      marketing_url: {
        "en-US" => "https://manzz.app"
      },
      privacy_url: {
        "en-US" => "https://manzz.app/privacy"
      },
      app_review_information: {
        contact_email: "dohrasanket@gmail.com",
        contact_first_name: "SANKETKUMAR",
        contact_last_name: "DOHRA",
        contact_phone: "+91 9265171259",
        demo_account_name: "",
        demo_account_password: "",
        notes: "Test app for ManzTestApp2025"
      },
      submission_information: {
        export_compliance_platform: "ios",
        export_compliance_compliance_required: false,
        export_compliance_encryption_updated: false,
        export_compliance_app_type: nil,
        export_compliance_uses_encryption: false,
        export_compliance_is_exempt: true,
        export_compliance_contains_third_party_cryptography: false,
        export_compliance_contains_proprietary_cryptography: false,
        export_compliance_available_on_french_store: false
      }
    )
  end

  desc "Update privacy details"
  lane :update_privacy_details do
    require 'spaceship'
    
    app_store_connect_api_key(
      key_id: ENV["APP_STORE_CONNECT_API_KEY_KEY_ID"],
      issuer_id: ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"],
      key_content: ENV["APP_STORE_CONNECT_API_KEY_KEY"]
    )
    
    # Get app ID
    app = Spaceship::ConnectAPI::App.find("com.san.mainAp")
    
    # Privacy settings need to be configured manually in App Store Connect
    # as there's no direct API support for privacy data collection settings yet
    UI.important("Privacy data collection settings must be configured manually in App Store Connect:")
    UI.message("1. Go to App Store Connect > Your App > App Privacy")
    UI.message("2. Set 'Data Collection' to 'Yes, we collect data from this app'")
    UI.message("3. Add these data types:")
    UI.message("   - Identifiers > Device ID (Analytics, App Functionality, Linked to User, Used for Tracking)")
    UI.message("   - Usage Data (Analytics, App Functionality, Linked to User, Used for Tracking)")
    UI.message("   - Advertising Data (Analytics, App Functionality, Linked to User, Used for Tracking)")
  end

  desc "Configure Pricing (Free) and Availability (All Countries)"
  lane :configure_pricing_and_availability do |options|
    bundle_id = options[:bundle_id] || "com.san.mainAp"

    UI.message("ğŸ’° Attempting direct API pricing setup for #{bundle_id}...")
    
    begin
      # Try direct HTTP API approach using session cookies
      require 'net/http'
      require 'json'
      require 'yaml'
      
      # Parse session cookies from environment
      session_data = YAML.load(ENV['FASTLANE_SESSION'])
      cookies = session_data.map { |cookie| "#{cookie.name}=#{cookie.value}" }.join('; ')
      
      UI.message("ğŸ” Using session cookies for direct API calls...")
      
      # Direct API call to set pricing
      uri = URI('https://appstoreconnect.apple.com/iris/v1/apps')
      http = Net::HTTP.new(uri.host, uri.port)
      http.use_ssl = true
      
      # Find app first
      request = Net::HTTP::Get.new(uri)
      request['Cookie'] = cookies
      request['Accept'] = 'application/json'
      
      response = http.request(request)
      
      if response.code == '200'
        apps_data = JSON.parse(response.body)
        app = apps_data['data'].find { |a| a['attributes']['bundleId'] == bundle_id }
        
        if app
          app_id = app['id']
          UI.success("âœ… Found app: #{app['attributes']['name']} (ID: #{app_id})")
          
          # Set pricing to free (tier 0) - try different endpoint structures
          pricing_endpoints = [
            "https://appstoreconnect.apple.com/iris/v1/apps/#{app_id}/appPrices",
            "https://appstoreconnect.apple.com/iris/v1/appPrices",
            "https://appstoreconnect.apple.com/WebObjects/iTunesConnect.woa/ra/apps/#{app_id}/pricing",
            "https://appstoreconnect.apple.com/iris/v1/apps/#{app_id}/relationships/prices"
          ]
          
          success = false
          pricing_endpoints.each_with_index do |endpoint, index|
            UI.message("ğŸ”„ Trying pricing endpoint #{index + 1}/#{pricing_endpoints.length}...")
            
            pricing_uri = URI(endpoint)
            pricing_request = Net::HTTP::Post.new(pricing_uri)
            pricing_request['Cookie'] = cookies
            pricing_request['Content-Type'] = 'application/json'
            pricing_request['Accept'] = 'application/json'
            pricing_request['X-Requested-With'] = 'XMLHttpRequest'
            
            pricing_data = {
              data: {
                type: 'appPrices',
                attributes: {
                  priceTier: 0,
                  startDate: nil
                },
                relationships: {
                  app: {
                    data: {
                      type: 'apps',
                      id: app_id
                    }
                  },
                  priceTier: {
                    data: {
                      type: 'appPriceTiers',
                      id: '0'
                    }
                  }
                }
              }
            }
            
            pricing_request.body = pricing_data.to_json
            pricing_response = http.request(pricing_request)
            
            UI.message("ğŸ“¡ Response: #{pricing_response.code} - #{pricing_response.message}")
            
            if pricing_response.code.start_with?('2')
              UI.success("âœ… Automated pricing setup completed via endpoint #{index + 1}!")
              UI.success("ğŸ”— Verify at: https://appstoreconnect.apple.com/apps/#{app_id}/distribution/pricing")
              success = true
              break
            elsif pricing_response.code == '404'
              UI.message("âš ï¸ Endpoint #{index + 1} not found, trying next...")
            else
              UI.message("âš ï¸ Endpoint #{index + 1} failed: #{pricing_response.code}")
            end
          end
          
          unless success
            raise "All pricing endpoints failed"
          end
        else
          raise "App not found"
        end
      else
        raise "Failed to fetch apps: #{response.code}"
      end
      
    rescue => e
      UI.error("âŒ Direct API approach failed: #{e.message}")
      UI.important("ğŸ“‹ MANUAL SETUP REQUIRED")
      UI.message("ğŸ”— Go to: https://appstoreconnect.apple.com/apps")
      UI.message("Click 'Add Pricing' â†’ Set to $0.00 (Free) â†’ Apply to all countries")
      UI.message("Click 'Set Up Availability' â†’ Select All Countries or Regions")
    end
  end

  desc "Complete build and upload process"
  lane :build_and_upload do |options|
    build_archive(options)
    create_app(options)
    configure_pricing_and_availability(options)
    upload_ipa(options)
    upload_metadata(options)
  end
end