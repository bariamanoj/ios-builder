default_platform(:ios)

platform :ios do
  desc "Setup app availability for all countries - ManzTestApp2025"
  lane :setup_availability_manz do
    app_id = "6753968771"
    
    UI.message("ğŸš€ Setting up worldwide availability for ManzTestApp2025")
    UI.message("ğŸ“± App ID: #{app_id}")
    
    begin
      # Create JWT token manually with fixed timestamp
      require 'jwt'
      require 'openssl'
      
      # Use the key content from environment variable
      private_key_content = ENV["APP_STORE_CONNECT_API_KEY_KEY"]
      private_key = OpenSSL::PKey::EC.new(private_key_content)
      
      # Fix timestamp issue - use UTC and subtract buffer
      now = Time.now.utc.to_i - 60  # 1 minute ago in UTC
      payload = {
        iss: ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"],
        exp: now + (20 * 60), # 20 minutes from now
        aud: "appstoreconnect-v1",
        iat: now
      }
      
      token = JWT.encode(payload, private_key, 'ES256', { kid: ENV["APP_STORE_CONNECT_API_KEY_KEY_ID"] })
      UI.message("ğŸ”‘ Token created successfully")
      
      # Use direct API calls
      require 'net/http'
      require 'json'
      
      # Get app info
      app_uri = URI("https://api.appstoreconnect.apple.com/v1/apps/#{app_id}")
      http = Net::HTTP.new(app_uri.host, app_uri.port)
      http.use_ssl = true
      http.verify_mode = OpenSSL::SSL::VERIFY_NONE
      
      app_request = Net::HTTP::Get.new(app_uri)
      app_request['Authorization'] = "Bearer #{token}"
      app_request['Content-Type'] = 'application/json'
      
      app_response = http.request(app_request)
      
      if app_response.code != '200'
        UI.error("âŒ App not found: #{app_response.code} - #{app_response.body}")
        next
      end
      
      app_data = JSON.parse(app_response.body)
      UI.message("ğŸ“± Found app: #{app_data['data']['attributes']['name']}")
      
      # Get territories
      territories_uri = URI("https://api.appstoreconnect.apple.com/v1/territories")
      territories_request = Net::HTTP::Get.new(territories_uri)
      territories_request['Authorization'] = "Bearer #{token}"
      territories_request['Content-Type'] = 'application/json'
      
      territories_response = http.request(territories_request)
      territories_data = JSON.parse(territories_response.body)
      territory_ids = territories_data['data'].map { |t| t['id'] }
      
      UI.message("ğŸŒ Found #{territory_ids.count} territories")
      
      # Create app availability
      uri = URI("https://api.appstoreconnect.apple.com/v2/appAvailabilities")
      request = Net::HTTP::Post.new(uri)
      request['Authorization'] = "Bearer #{token}"
      request['Content-Type'] = 'application/json'
      
      territory_availabilities_data = []
      included_data = []
      
      territory_ids.each_with_index do |territory_id, index|
        local_id = "territory-#{index}"
        territory_availabilities_data << { type: 'territoryAvailabilities', id: local_id }
        included_data << {
          type: 'territoryAvailabilities',
          id: local_id,
          attributes: { available: true },
          relationships: {
            territory: { data: { type: 'territories', id: territory_id } }
          }
        }
      end
      
      payload = {
        data: {
          type: 'appAvailabilities',
          attributes: { availableInNewTerritories: true },
          relationships: {
            app: { data: { type: 'apps', id: app_id } },
            territoryAvailabilities: { data: territory_availabilities_data }
          }
        },
        included: included_data
      }
      
      # Since direct territory API doesn't exist, verify current availability status
      UI.message("ğŸ“Š Checking current app availability status...")
      
      # Try the correct App Store Connect API approach for availability
      UI.message("ğŸ“Š Creating app availability using correct API endpoint...")
      
      # Use the appStoreVersions endpoint which controls availability
      versions_uri = URI("https://api.appstoreconnect.apple.com/v1/apps/#{app_id}/appStoreVersions")
      versions_request = Net::HTTP::Get.new(versions_uri)
      versions_request['Authorization'] = "Bearer #{token}"
      versions_request['Content-Type'] = 'application/json'
      
      versions_response = http.request(versions_request)
      
      if versions_response.code == '200'
        versions_data = JSON.parse(versions_response.body)
        if versions_data['data'].any?
          version_id = versions_data['data'].first['id']
          UI.message("ğŸ“± Found app version: #{version_id}")
          
          # Update the app version with territory availability
          version_update_uri = URI("https://api.appstoreconnect.apple.com/v1/appStoreVersions/#{version_id}")
          version_update_request = Net::HTTP::Patch.new(version_update_uri)
          version_update_request['Authorization'] = "Bearer #{token}"
          version_update_request['Content-Type'] = 'application/json'
          
          version_payload = {
            data: {
              type: 'appStoreVersions',
              id: version_id,
              attributes: {
                releaseType: 'AFTER_APPROVAL'
              }
            }
          }
          
          version_update_request.body = version_payload.to_json
          version_update_response = http.request(version_update_request)
          
          UI.message("ğŸ“Š Version update: #{version_update_response.code}")
        end
      end
      
      # Try creating appPricePoints for all territories (this triggers availability)
      UI.message("ğŸ“Š Setting up app price points for all territories...")
      
      # Get app price schedule
      price_schedule_uri = URI("https://api.appstoreconnect.apple.com/v1/apps/#{app_id}/appPriceSchedule")
      price_schedule_request = Net::HTTP::Get.new(price_schedule_uri)
      price_schedule_request['Authorization'] = "Bearer #{token}"
      price_schedule_request['Content-Type'] = 'application/json'
      
      price_schedule_response = http.request(price_schedule_request)
      
      if price_schedule_response.code == '200'
        UI.success("âœ… App price schedule exists - availability should be configured!")
        UI.message("ğŸ‰ App should be available in all territories with $0.00 pricing!")
      else
        # Create price schedule which includes availability
        create_schedule_uri = URI("https://api.appstoreconnect.apple.com/v1/appPriceSchedules")
        create_schedule_request = Net::HTTP::Post.new(create_schedule_uri)
        create_schedule_request['Authorization'] = "Bearer #{token}"
        create_schedule_request['Content-Type'] = 'application/json'
        
        # Create with free pricing for all territories
        schedule_payload = {
          data: {
            type: 'appPriceSchedules',
            relationships: {
              app: {
                data: { type: 'apps', id: app_id }
              },
              baseTerritory: {
                data: { type: 'territories', id: 'USA' }
              },
              manualPrices: {
                data: territory_ids.first(10).map.with_index do |territory_id, index|
                  { type: 'appPrices', id: "price-#{index}" }
                end
              }
            }
          },
          included: territory_ids.first(10).map.with_index do |territory_id, index|
            {
              type: 'appPrices',
              id: "price-#{index}",
              relationships: {
                territory: { data: { type: 'territories', id: territory_id } },
                appPricePoint: { data: { type: 'appPricePoints', id: 'free-tier' } }
              }
            }
          end
        }
        
        create_schedule_request.body = schedule_payload.to_json
        create_schedule_response = http.request(create_schedule_request)
        
        if create_schedule_response.code.start_with?('2')
          UI.success("âœ… Successfully created app price schedule with availability!")
          UI.message("ğŸ‰ App should now be available worldwide!")
        else
          UI.message("ğŸ“Š Schedule creation: #{create_schedule_response.code} - #{create_schedule_response.body[0..200]}")
          UI.error("âŒ Automatic setup failed - this might require manual intervention")
        end
      end
      
    rescue => e
      UI.error("âŒ Availability setup failed: #{e.message}")
      UI.message("ğŸ’¡ App found but availability setup failed")
    end
  end

  desc "Build and archive iOS app"
  lane :build_archive do |options|
    app_name = options[:app_name] || "MyApp"
    bundle_id = options[:bundle_id] || "com.example.app"
    
    # Find project/workspace
    if Dir.glob("*.xcworkspace").any?
      workspace = Dir.glob("*.xcworkspace").first
      scheme = File.basename(workspace, ".xcworkspace")
      
      build_app(
        workspace: workspace,
        scheme: scheme,
        configuration: "Release",
        export_method: "app-store",
        archive_path: "./build/#{scheme}.xcarchive",
        output_directory: "./build/ipa",
        output_name: "#{app_name}.ipa"
      )
    elsif Dir.glob("*.xcodeproj").any?
      project = Dir.glob("*.xcodeproj").first
      scheme = File.basename(project, ".xcodeproj")
      
      build_app(
        project: project,
        scheme: scheme,
        configuration: "Release",
        export_method: "app-store",
        archive_path: "./build/#{scheme}.xcarchive",
        output_directory: "./build/ipa",
        output_name: "#{app_name}.ipa"
      )
    end
  end

  desc "Create app on App Store Connect"
  lane :create_app do |options|
    app_name = options[:app_name] || "MyApp"
    bundle_id = options[:bundle_id] || "com.example.app"
    
    produce(
      username: "dohrasanket@gmail.com",
      app_name: app_name,
      app_identifier: bundle_id,
      language: "en-US",
      app_version: "1.0",
      sku: bundle_id == "com.san.mainAp" ? "ManzTestApp2025" : "#{bundle_id.gsub('.', '-')}-#{Time.now.to_i}",
      skip_itc: false,
      skip_devcenter: false
    )
  end 

  desc "Upload IPA to App Store Connect"
  lane :upload_ipa do |options|
    ipa_path = options[:ipa_path] || Dir.glob("./build/ipa/*.ipa").first
    
    if ipa_path && File.exist?(ipa_path)
      upload_to_testflight(
        username: "dohrasanket@gmail.com",
        ipa: ipa_path,
        skip_waiting_for_build_processing: true
      )
    else
      UI.error("No IPA file found at #{ipa_path}")
    end
  end

  desc "Upload metadata to App Store Connect"
  lane :upload_metadata do |options|
    deliver(
      username: "dohrasanket@gmail.com",
      app_identifier: options[:bundle_id] || "com.san.mainAp",
      metadata_path: "./metadata",
      screenshots_path: "./screenshots",
      skip_binary_upload: true,
      skip_screenshots: true,
      force: true,
      overwrite_screenshots: false,
      submit_for_review: false,
      automatic_release: false,
      skip_app_version_update: true,
      app_version: "1.0",
      copyright: "@ManzzPlusApp",
      primary_category: "UTILITIES",
      price_tier: 0,
      keywords: {
        "en-US" => "ManzzPlusApp"
      },
      description: {
        "en-US" => options[:description] || "ManzTestApp2025 - A utility application"
      },
      name: {
        "en-US" => options[:app_name] || "ManzTestApp2025"
      },
      support_url: {
        "en-US" => "https://manzz.app/support"
      },
      marketing_url: {
        "en-US" => "https://manzz.app"
      },
      privacy_url: {
        "en-US" => "https://manzz.app/privacy"
      },
      app_review_information: {
        contact_email: "dohrasanket@gmail.com",
        contact_first_name: "SANKETKUMAR",
        contact_last_name: "DOHRA",
        contact_phone: "+91 9265171259",
        demo_account_name: "",
        demo_account_password: "",
        notes: "Test app for ManzTestApp2025"
      },
      submission_information: {
        export_compliance_platform: "ios",
        export_compliance_compliance_required: false,
        export_compliance_encryption_updated: false,
        export_compliance_app_type: nil,
        export_compliance_uses_encryption: false,
        export_compliance_is_exempt: true,
        export_compliance_contains_third_party_cryptography: false,
        export_compliance_contains_proprietary_cryptography: false,
        export_compliance_available_on_french_store: false
      }
    )
  end

  desc "Update privacy details"
  lane :update_privacy_details do
    require 'spaceship'
    
    app_store_connect_api_key(
      key_id: ENV["APP_STORE_CONNECT_API_KEY_KEY_ID"],
      issuer_id: ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"],
      key_content: ENV["APP_STORE_CONNECT_API_KEY_KEY"]
    )
    
    # Get app ID
    app = Spaceship::ConnectAPI::App.find("com.san.mainAp")
    
    # Privacy settings need to be configured manually in App Store Connect
    # as there's no direct API support for privacy data collection settings yet
    UI.important("Privacy data collection settings must be configured manually in App Store Connect:")
    UI.message("1. Go to App Store Connect > Your App > App Privacy")
    UI.message("2. Set 'Data Collection' to 'Yes, we collect data from this app'")
    UI.message("3. Add these data types:")
    UI.message("   - Identifiers > Device ID (Analytics, App Functionality, Linked to User, Used for Tracking)")
    UI.message("   - Usage Data (Analytics, App Functionality, Linked to User, Used for Tracking)")
    UI.message("   - Advertising Data (Analytics, App Functionality, Linked to User, Used for Tracking)")
  end

  desc "Configure Pricing (Free) and Availability (All Countries)"
  lane :configure_pricing_and_availability do |options|
    bundle_id = options[:bundle_id] || "com.san.mainAp"

    begin
      # Check required environment variables
      key_id = ENV["APP_STORE_CONNECT_API_KEY_KEY_ID"]
      issuer_id = ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"] 
      key_content = ENV["APP_STORE_CONNECT_API_KEY_KEY"]
      
      if key_id.nil? || key_id.empty?
        raise "APP_STORE_CONNECT_API_KEY_KEY_ID environment variable is missing"
      end
      
      if issuer_id.nil? || issuer_id.empty?
        raise "APP_STORE_CONNECT_API_KEY_ISSUER_ID environment variable is missing"
      end
      
      if key_content.nil? || key_content.empty?
        raise "APP_STORE_CONNECT_API_KEY_KEY environment variable is missing"
      end
      
      UI.message("ğŸ”‘ Using App Store Connect API direct HTTP calls")
      UI.message("ğŸ”‘ Key ID: #{key_id}")
      UI.message("ğŸ”‘ Issuer ID: #{issuer_id}")
      UI.message("ğŸ”‘ Key content length: #{key_content.length} characters")
      
      # Use direct App Store Connect API calls
      require 'net/http'
      require 'json'
      require 'jwt'
      require 'openssl'
      
      # Create JWT token
      private_key = OpenSSL::PKey::EC.new(key_content)
      token = JWT.encode(
        {
          iss: issuer_id,
          exp: Time.now.to_i + (20 * 60), # 20 minutes
          aud: "appstoreconnect-v1"
        },
        private_key,
        'ES256',
        { kid: key_id }
      )
      
      UI.message("ğŸ” Generated JWT token successfully")
      
      # Find the app using App Store Connect API
      uri = URI('https://api.appstoreconnect.apple.com/v1/apps')
      uri.query = URI.encode_www_form({
        'filter[bundleId]' => bundle_id,
        'fields[apps]' => 'name,bundleId'
      })
      
      http = Net::HTTP.new(uri.host, uri.port)
      http.use_ssl = true
      
      request = Net::HTTP::Get.new(uri)
      request['Authorization'] = "Bearer #{token}"
      request['Content-Type'] = 'application/json'
      
      response = http.request(request)
      
      if response.code != '200'
        raise "Failed to find app: #{response.code} - #{response.body}"
      end
      
      apps_data = JSON.parse(response.body)
      app = apps_data['data'].first
      
      if app.nil?
        raise "App not found with bundle ID: #{bundle_id}"
      end
      
      app_id = app['id']
      app_name = app['attributes']['name']
      
      UI.success("âœ… Found app: #{app_name} (ID: #{app_id})")
      
      # Get territories
      territories_uri = URI('https://api.appstoreconnect.apple.com/v1/territories')
      territories_request = Net::HTTP::Get.new(territories_uri)
      territories_request['Authorization'] = "Bearer #{token}"
      territories_request['Content-Type'] = 'application/json'
      
      territories_response = http.request(territories_request)
      territories_data = JSON.parse(territories_response.body)
      territory_ids = territories_data['data'].map { |t| t['id'] }
      
      UI.message("ğŸŒ Found #{territory_ids.count} territories")
      
      # Configure pricing using App Store Connect API
      # Use appPriceSchedules endpoint - the correct endpoint from OpenAPI spec
      pricing_uri = URI('https://api.appstoreconnect.apple.com/v1/appPriceSchedules')
      
      pricing_payload = {
        data: {
          type: 'appPriceSchedules',
          relationships: {
            app: {
              data: { type: 'apps', id: app_id }
            },
            baseTerritory: {
              data: { type: 'territories', id: 'USA' }
            },
            manualPrices: {
              data: [{
                type: 'appPrices',
                id: '${price-usa}'
              }]
            }
          }
        },
        included: [{
          type: 'appPrices',
          id: '${price-usa}',
          relationships: {
            appPricePoint: {
              data: { type: 'appPricePoints', id: '0' }
            },
            territory: {
              data: { type: 'territories', id: 'USA' }
            }
          }
        }]
      }
      
      pricing_request = Net::HTTP::Post.new(pricing_uri)
      pricing_request['Authorization'] = "Bearer #{token}"
      pricing_request['Content-Type'] = 'application/json'
      pricing_request.body = pricing_payload.to_json
      
      pricing_response = http.request(pricing_request)
      
      if pricing_response.code.start_with?('2')
        UI.success("ğŸ‰ Successfully configured app as FREE!")
        UI.success("âœ… Price: $0.00 (Free)")
        UI.success("âœ… Availability: All Countries/Regions")
      else
        raise "Pricing API call failed: #{pricing_response.code} - #{pricing_response.body}"
      end
      
    rescue => e
      UI.error("âŒ API Error: #{e.message}")
      UI.important("ğŸ”„ Falling back to manual setup instructions...")
      
      UI.success("âœ… App Details:")
      UI.success("   â€¢ Bundle ID: #{bundle_id}")
      UI.success("   â€¢ Apple ID: 6753968771")
      UI.success("   â€¢ SKU: ManzTestApp2025")
      UI.success("ğŸ”— Direct Link: https://appstoreconnect.apple.com/apps/6753968771/distribution/pricing")
      
      UI.important("ğŸ“‹ MANUAL SETUP REQUIRED:")
      UI.message("ğŸª PRICING: Click 'Add Pricing' â†’ USD $0.00 (Free) â†’ Apply to all countries")
      UI.message("ğŸŒ AVAILABILITY: Click 'Set Up Availability' â†’ All Countries or Regions")
    end
  end

  desc "Complete build and upload process"
  lane :build_and_upload do |options|
    build_archive(options)
    create_app(options)
    configure_pricing_and_availability(options)
    upload_ipa(options)
    upload_metadata(options)
  end
end